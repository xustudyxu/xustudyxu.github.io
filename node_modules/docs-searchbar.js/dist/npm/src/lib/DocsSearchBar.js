"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _autocomplete = _interopRequireDefault(require("autocomplete.js"));

var _templates = _interopRequireDefault(require("./templates"));

var _utils = _interopRequireDefault(require("./utils"));

var _zepto = _interopRequireDefault(require("./zepto"));

var _meilisearch = require("meilisearch");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Adds an autocomplete dropdown to an input field
 * @function DocsSearchBar
 * @param  {string}            options.hostUrl               URL where MeiliSearch instance is hosted
 * @param  {string}            options.apiKey                Read-only API key
 * @param  {string}            options.indexUid              UID of the index to target
 * @param  {string}            options.inputSelector         CSS selector that targets the input
 * @param  {boolean}           [options.debug]               When set to true, the dropdown will not be closed on blur
 * @param  {Object}            [options.meilisearchOptions]  Options to pass the underlying MeiliSearch client
 * @param  {function}          [options.queryDataCallback]   This function will be called when querying MeiliSearch
 * @param  {Object}            [options.autocompleteOptions] Options to pass to the underlying autocomplete instance
 * @param  {function}          [options.transformData]       An optional function to transform the hits
 * @param  {function}          [options.queryHook]           An optional function to transform the query
 * @param  {function}          [options.handleSelected]      This function is called when a suggestion is selected
 * @param  {function}          [options.enhancedSearchInput] When set to true, a theme is applied to the search box to improve its appearance
 * @param  {'column'|'simple'} [options.layout]              Layout of the search bar
 * @param  {boolean|'auto'}    [options.enableDarkMode]      Allows you to enforce, light theme, dark theme, or auto mode on the searchbar.
 * @return {Object}
 */
var usage = "Usage:\n  documentationSearch({\n  hostUrl,\n  apiKey,\n  indexUid,\n  inputSelector,\n  [ debug ],\n  [ meilisearchOptions ],\n  [ queryDataCallback ],\n  [ autocompleteOptions ],\n  [ transformData ],\n  [ queryHook ],\n  [ handleSelected ],\n  [ enhancedSearchInput ],\n  [ layout ],\n  [ enableDarkMode ]\n})";

var DocsSearchBar = /*#__PURE__*/function () {
  function DocsSearchBar(_ref) {
    var hostUrl = _ref.hostUrl,
        apiKey = _ref.apiKey,
        indexUid = _ref.indexUid,
        inputSelector = _ref.inputSelector,
        _ref$debug = _ref.debug,
        debug = _ref$debug === void 0 ? false : _ref$debug,
        _ref$meilisearchOptio = _ref.meilisearchOptions,
        meilisearchOptions = _ref$meilisearchOptio === void 0 ? {} : _ref$meilisearchOptio,
        _ref$queryDataCallbac = _ref.queryDataCallback,
        queryDataCallback = _ref$queryDataCallbac === void 0 ? null : _ref$queryDataCallbac,
        _ref$autocompleteOpti = _ref.autocompleteOptions,
        autocompleteOptions = _ref$autocompleteOpti === void 0 ? {} : _ref$autocompleteOpti,
        _ref$transformData = _ref.transformData,
        transformData = _ref$transformData === void 0 ? false : _ref$transformData,
        _ref$queryHook = _ref.queryHook,
        queryHook = _ref$queryHook === void 0 ? false : _ref$queryHook,
        _ref$handleSelected = _ref.handleSelected,
        handleSelected = _ref$handleSelected === void 0 ? false : _ref$handleSelected,
        _ref$enhancedSearchIn = _ref.enhancedSearchInput,
        enhancedSearchInput = _ref$enhancedSearchIn === void 0 ? false : _ref$enhancedSearchIn,
        _ref$layout = _ref.layout,
        layout = _ref$layout === void 0 ? 'columns' : _ref$layout,
        _ref$enableDarkMode = _ref.enableDarkMode,
        enableDarkMode = _ref$enableDarkMode === void 0 ? false : _ref$enableDarkMode;

    _classCallCheck(this, DocsSearchBar);

    DocsSearchBar.checkArguments({
      hostUrl: hostUrl,
      apiKey: apiKey,
      indexUid: indexUid,
      inputSelector: inputSelector,
      debug: debug,
      meilisearchOptions: meilisearchOptions,
      queryDataCallback: queryDataCallback,
      autocompleteOptions: autocompleteOptions,
      transformData: transformData,
      queryHook: queryHook,
      handleSelected: handleSelected,
      enhancedSearchInput: enhancedSearchInput,
      layout: layout,
      enableDarkMode: enableDarkMode
    });
    this.apiKey = apiKey;
    this.hostUrl = hostUrl;
    this.indexUid = indexUid;
    this.input = DocsSearchBar.getInputFromSelector(inputSelector);
    this.meilisearchOptions = _objectSpread({
      limit: 5,
      attributesToHighlight: ['*'],
      attributesToCrop: ['content'],
      cropLength: 30
    }, meilisearchOptions);
    this.queryDataCallback = queryDataCallback || null;
    this.autocompleteOptions = _objectSpread({
      debug: debug,
      hint: false,
      autoselect: true
    }, autocompleteOptions);
    var inputAriaLabel = this.input && typeof this.input.attr === 'function' && this.input.attr('aria-label');
    this.autocompleteOptions.ariaLabel = this.autocompleteOptions.ariaLabel || inputAriaLabel || 'search input';
    this.autocompleteOptions.cssClasses = this.autocompleteOptions.cssClasses || {};
    this.autocompleteOptions.cssClasses.prefix = this.autocompleteOptions.cssClasses.prefix || 'dsb';
    this.autocompleteOptions.cssClasses.root = this.autocompleteOptions.cssClasses.root || 'meilisearch-autocomplete';
    this.autocompleteOptions.keyboardShortcuts = this.parseHotkeysAutocompleteOptions(this.autocompleteOptions.keyboardShortcuts) || ['s', 191];
    this.isSimpleLayout = layout === 'simple';
    this.enableDarkMode = enableDarkMode;
    this.client = new _meilisearch.MeiliSearch({
      host: hostUrl,
      apiKey: this.apiKey
    });
    DocsSearchBar.addThemeWrapper(inputSelector, this.enableDarkMode);

    if (enhancedSearchInput) {
      this.input = DocsSearchBar.injectSearchBox(this.input);
    }

    this.autocomplete = (0, _autocomplete.default)(this.input, this.autocompleteOptions, [{
      source: this.getAutocompleteSource(transformData, queryHook),
      templates: {
        suggestion: DocsSearchBar.getSuggestionTemplate(this.isSimpleLayout),
        footer: _templates.default.footer,
        empty: DocsSearchBar.getEmptyTemplate()
      }
    }]); // We remove the inline styles of the wrapper element for left / right

    (0, _zepto.default)(".".concat(this.autocompleteOptions.cssClasses.root, " > [role='listbox']")).css({
      left: false,
      right: false
    });
    var customHandleSelected = handleSelected;
    this.handleSelected = customHandleSelected || this.handleSelected; // We prevent default link clicking if a custom handleSelected is defined

    if (customHandleSelected) {
      (0, _zepto.default)('.meilisearch-autocomplete').on('click', ".".concat(this.autocompleteOptions.cssClasses.prefix, "-suggestions a"), function (event) {
        event.preventDefault();
      });
    }

    this.autocomplete.on('autocomplete:selected', this.handleSelected.bind(null, this.autocomplete.autocomplete));
    this.autocomplete.on('autocomplete:shown', this.handleShown.bind(null, this.input));

    if (enhancedSearchInput) {
      DocsSearchBar.bindSearchBoxEvent();
    }
  }
  /**
   * Wraps input selector in a docs-searchbar-js div
   * @function addThemeWrapper
   * @param  {string} inputSelector Selector of the input element
   * @param  {boolean|'auto'} enableDarkMode Allows you to enforce, light theme, dark theme, or auto mode on the searchbar.
   * @returns {void}
   */


  _createClass(DocsSearchBar, [{
    key: "getAutocompleteSource",
    value:
    /**
     * Returns the `source` method to be passed to autocomplete.js. It will query
     * the MeiliSearch index and call the callbacks with the formatted hits.
     * @function getAutocompleteSource
     * @param  {function} transformData An optional function to transform the hits
     * @param {function} queryHook An optional function to transform the query
     * @returns {function} Method to be passed as the `source` option of
     * autocomplete
     */
    function getAutocompleteSource(transformData, queryHook) {
      var _this = this;

      return function (query, callback) {
        if (queryHook) {
          // eslint-disable-next-line no-param-reassign
          query = queryHook(query) || query;
        }

        _this.client.index(_this.indexUid).search(query, _this.meilisearchOptions).then(function (data) {
          if (_this.queryDataCallback && typeof _this.queryDataCallback === 'function') {
            _this.queryDataCallback(data);
          }

          var hits = data.hits;

          if (transformData) {
            hits = transformData(hits) || hits;
          }

          callback(DocsSearchBar.formatHits(hits));
        });
      };
    } // Given a list of hits returned by the API, will reformat them to be used in
    // a template

  }, {
    key: "handleSelected",
    value: function handleSelected(input, event, suggestion, datasetNumber) {
      var context = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

      // Do nothing if click on the suggestion, as it's already a <a href>, the
      // browser will take care of it. This allow Ctrl-Clicking on results and not
      // having the main window being redirected as well
      if (context.selectionMethod === 'click') {
        return;
      }

      input.setVal('');
      window.location.assign(suggestion.url);
    }
  }, {
    key: "handleShown",
    value: function handleShown(input) {
      var middleOfInput = input.offset().left + input.width() / 2;
      var middleOfWindow = (0, _zepto.default)(document).width() / 2;

      if (isNaN(middleOfWindow)) {
        middleOfWindow = 900;
      }

      var alignClass = middleOfInput - middleOfWindow >= 0 ? 'meilisearch-autocomplete-right' : 'meilisearch-autocomplete-left';
      var otherAlignClass = middleOfInput - middleOfWindow < 0 ? 'meilisearch-autocomplete-right' : 'meilisearch-autocomplete-left';
      var autocompleteWrapper = (0, _zepto.default)('.meilisearch-autocomplete');

      if (!autocompleteWrapper.hasClass(alignClass)) {
        autocompleteWrapper.addClass(alignClass);
      }

      if (autocompleteWrapper.hasClass(otherAlignClass)) {
        autocompleteWrapper.removeClass(otherAlignClass);
      }
    }
  }, {
    key: "parseHotkeysAutocompleteOptions",
    value: function parseHotkeysAutocompleteOptions(hotkeys) {
      if (hotkeys === undefined || hotkeys === null) {
        return null;
      }

      return hotkeys.map(function (item) {
        return item === '/' ? 191 : item;
      });
    }
  }], [{
    key: "addThemeWrapper",
    value: function addThemeWrapper(inputSelector, enableDarkMode) {
      var inputElement = document.querySelector(inputSelector);
      var parent = inputElement.parentNode;
      var wrapper = document.createElement('div');
      wrapper.className += 'docs-searchbar-js';
      parent.replaceChild(wrapper, inputElement);
      wrapper.appendChild(inputElement);
      var isSystemInDarkMode = Boolean(enableDarkMode);

      if (enableDarkMode === 'auto' && window.matchMedia) {
        var mediaQueryList = window.matchMedia('(prefers-color-scheme: dark)');
        isSystemInDarkMode = mediaQueryList.matches;

        var listener = function listener(e) {
          if (document.body.contains(wrapper)) {
            wrapper.setAttribute('data-ds-theme', e.matches ? 'dark' : 'light');
          } else if (mediaQueryList.removeEventListener) {
            mediaQueryList.removeEventListener('change', listener);
          } else if (mediaQueryList.removeListener) {
            mediaQueryList.removeListener(listener);
          }
        };

        if (mediaQueryList.addEventListener) {
          mediaQueryList.addEventListener('change', listener);
        } else if (mediaQueryList.addListener) {
          mediaQueryList.addListener(listener);
        }
      }

      wrapper.setAttribute('data-ds-theme', isSystemInDarkMode ? 'dark' : 'light');
    }
    /**
     * Checks that the passed arguments are valid. Will throw errors otherwise
     * @function checkArguments
     * @param  {object} args Arguments as an option object
     * @returns {void}
     */

  }, {
    key: "checkArguments",
    value: function checkArguments(args) {
      if (!args.inputSelector || !args.indexUid || !args.hostUrl) {
        throw new Error(usage);
      }

      if (typeof args.inputSelector !== 'string') {
        throw new Error("Error: inputSelector:".concat(args.inputSelector, "  must be a string. Each selector must match only one element and separated by ','"));
      }

      if (!DocsSearchBar.getInputFromSelector(args.inputSelector)) {
        throw new Error("Error: No input element in the page matches ".concat(args.inputSelector));
      }

      DocsSearchBar.typeCheck(args, ['meilisearchOptions', 'autocompleteOptions'], 'object', true);

      if (args.enableDarkMode !== 'auto' && args.enableDarkMode !== false && args.enableDarkMode !== true) {
        throw new Error("Error: \"enableDarkMode\" must be either true, false, or 'auto'. Supplied value: ".concat(args.enableDarkMode));
      }

      DocsSearchBar.typeCheck(args, ['debug', 'enhancedSearchInput'], 'boolean', false);
      DocsSearchBar.typeCheck(args, ['queryDataCallback', 'transformData', 'queryHook', 'handleSelected'], 'function', true);

      if (args.layout && !['simple', 'columns'].includes(args.layout)) {
        throw new Error("Error: \"layout\" must be either 'columns' or 'simple'. Supplied value: ".concat(args.layout));
      }
    }
    /**
     * Checks if the arguments defined in the check variable are of the supplied
     * type
     * @param {any[]} args all arguments
     * @param {string[]} checkArguments array with the argument names to check
     * @param {string} type required type for the arguments
     * @param {boolean} optional don't check argument if it's falsy
     * @returns {void}
     */

  }, {
    key: "typeCheck",
    value: function typeCheck(args, checkArguments, type, optional) {
      checkArguments.filter(function (argument) {
        return !optional || args[argument];
      }).forEach(function (argument) {
        var value = args[argument];

        if (_typeof(args[argument]) !== type) {
          throw new Error("Error: \"".concat(argument, "\" must be of type: ").concat(type, ". Found type: ").concat(_typeof(value)));
        }
      });
    }
  }, {
    key: "injectSearchBox",
    value: function injectSearchBox(input) {
      input.before(_templates.default.searchBox);
      var newInput = input.prev().prev().find('input');
      input.remove();
      return newInput;
    }
  }, {
    key: "bindSearchBoxEvent",
    value: function bindSearchBoxEvent() {
      (0, _zepto.default)('.searchbox [type="reset"]').on('click', function () {
        (0, _zepto.default)('input#docs-searchbar').focus();
        (0, _zepto.default)(this).addClass('hide');

        _autocomplete.default.autocomplete.setVal('');
      });
      (0, _zepto.default)('input#docs-searchbar').on('keyup', function () {
        var searchbox = document.querySelector('input#docs-searchbar');
        var reset = document.querySelector('.searchbox [type="reset"]');
        reset.className = 'searchbox__reset';

        if (searchbox.value.length === 0) {
          reset.className += ' hide';
        }
      });
    }
    /**
     * Returns the matching input from a CSS selector, null if none matches
     * @function getInputFromSelector
     * @param  {string} selector CSS selector that matches the search
     * input of the page
     * @returns {void}
     */

  }, {
    key: "getInputFromSelector",
    value: function getInputFromSelector(selector) {
      var input = (0, _zepto.default)(selector).filter('input');
      return input.length ? (0, _zepto.default)(input[0]) : null;
    }
  }, {
    key: "formatHits",
    value: function formatHits(receivedHits) {
      var clonedHits = _utils.default.deepClone(receivedHits);

      var hits = clonedHits.map(function (hit) {
        if (hit._formatted) {
          var cleanFormatted = _utils.default.replaceNullString(hit._formatted); // eslint-disable-next-line no-param-reassign


          hit._formatted = _utils.default.renameKeysWithLevels(cleanFormatted, 'hierarchy_');
        }

        var cleanHit = _utils.default.replaceNullString(hit);

        return _utils.default.renameKeysWithLevels(cleanHit, 'hierarchy_');
      }); // Group hits by category / subcategory

      var groupedHits = _utils.default.groupBy(hits, 'lvl0');

      _zepto.default.each(groupedHits, function (level, collection) {
        var groupedHitsByLvl1 = _utils.default.groupBy(collection, 'lvl1');

        var flattenedHits = _utils.default.flattenAndFlagFirst(groupedHitsByLvl1, 'isSubCategoryHeader');

        groupedHits[level] = flattenedHits;
      });

      groupedHits = _utils.default.flattenAndFlagFirst(groupedHits, 'isCategoryHeader'); // Translate hits into smaller objects to be send to the template

      return groupedHits.map(function (hit) {
        var url = DocsSearchBar.formatURL(hit);

        var category = _utils.default.getHighlightedValue(hit, 'lvl0');

        var subcategory = _utils.default.getHighlightedValue(hit, 'lvl1') || category;

        var displayTitle = _utils.default.compact([_utils.default.getHighlightedValue(hit, 'lvl2') || subcategory, _utils.default.getHighlightedValue(hit, 'lvl3'), _utils.default.getHighlightedValue(hit, 'lvl4'), _utils.default.getHighlightedValue(hit, 'lvl5'), _utils.default.getHighlightedValue(hit, 'lvl6')]).join('<span class="aa-suggestion-title-separator" aria-hidden="true"> â€º </span>');

        var text = _utils.default.getSnippetedValue(hit, 'content');

        var isTextOrSubcategoryNonEmpty = subcategory && subcategory !== '' || displayTitle && displayTitle !== '';
        var isLvl1EmptyOrDuplicate = !subcategory || subcategory === '' || subcategory === category;
        var isLvl2 = displayTitle && displayTitle !== '' && displayTitle !== subcategory;
        var isLvl1 = !isLvl2 && subcategory && subcategory !== '' && subcategory !== category;
        var isLvl0 = !isLvl1 && !isLvl2;
        return {
          isLvl0: isLvl0,
          isLvl1: isLvl1,
          isLvl2: isLvl2,
          isLvl1EmptyOrDuplicate: isLvl1EmptyOrDuplicate,
          isCategoryHeader: hit.isCategoryHeader,
          isSubCategoryHeader: hit.isSubCategoryHeader,
          isTextOrSubcategoryNonEmpty: isTextOrSubcategoryNonEmpty,
          category: category,
          subcategory: subcategory,
          title: displayTitle,
          text: text,
          url: url
        };
      });
    }
  }, {
    key: "formatURL",
    value: function formatURL(hit) {
      var url = hit.url,
          anchor = hit.anchor;

      if (url) {
        var containsAnchor = url.indexOf('#') !== -1;
        if (containsAnchor) return url;else if (anchor) return "".concat(hit.url, "#").concat(hit.anchor);
        return url;
      } else if (anchor) return "#".concat(hit.anchor);

      console.warn('no anchor nor url for : ', JSON.stringify(hit));
      return null;
    }
  }, {
    key: "getEmptyTemplate",
    value: function getEmptyTemplate() {
      return _templates.default.empty;
    }
  }, {
    key: "getSuggestionTemplate",
    value: function getSuggestionTemplate(isSimpleLayout) {
      return isSimpleLayout ? _templates.default.suggestionSimple : _templates.default.suggestion;
    }
  }]);

  return DocsSearchBar;
}();

var _default = DocsSearchBar;
exports.default = _default;