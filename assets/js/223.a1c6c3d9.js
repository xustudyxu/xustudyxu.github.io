(window.webpackJsonp=window.webpackJsonp||[]).push([[223],{574:function(e,r,s){"use strict";s.r(r);var t=s(10),a=Object(t.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"hbase系统架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hbase系统架构"}},[e._v("#")]),e._v(" HBase系统架构")]),e._v(" "),r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#客户端"}},[e._v("客户端")])]),r("li",[r("a",{attrs:{href:"#zookeeper"}},[e._v("ZooKeeper")])]),r("li",[r("a",{attrs:{href:"#hmaster"}},[e._v("HMaster")])]),r("li",[r("a",{attrs:{href:"#regionserver"}},[e._v("RegionServer")])]),r("li",[r("a",{attrs:{href:"#hbase相关概念"}},[e._v("Hbase相关概念")])]),r("li",[r("a",{attrs:{href:"#逻辑模型"}},[e._v("逻辑模型")])]),r("li",[r("a",{attrs:{href:"#物理模型"}},[e._v("物理模型")])]),r("li",[r("a",{attrs:{href:"#实际存储方式"}},[e._v("实际存储方式")])])])]),r("p"),e._v(" "),r("p",[e._v("HBase是一个高可靠、高性能、面向列、可伸缩的分布式数据库，底层基大数据存储与管理于Hadoop的HDFS来存储数据。\nHBase的系统架构包括"),r("strong",[e._v("客户端、Zookeeper服务器、HMaster服务器、和RegionServer服务器")]),e._v("这些组件。HBase集群也是主从模式，HMaster是主服务器，regionServer是从服务器，在集群中可允许有多个regionserver。")]),e._v(" "),r("p",[e._v("同时regionserver上有多个region，region是HBase中数据的物理分片。HBase的底层是HDFS的数据节点，HBase中的数据最终是存储在HDFS上的。")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://jsdelivr.codeqihan.com//gh/xustudyxu/image-hosting@master/studynotes/HBase/images/03/01.png",alt:"01"}})]),e._v(" "),r("h2",{attrs:{id:"客户端"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#客户端"}},[e._v("#")]),e._v(" 客户端")]),e._v(" "),r("ul",[r("li",[e._v("HBase系统的入口\n"),r("ul",[r("li",[e._v("客户端是任务的发起者；它是整个储与管理HBase系统的入口，使用者直接通过客户\n端来操作Hbase。")])])]),e._v(" "),r("li",[e._v("通信功能\n"),r("ul",[r("li",[e._v("客户端与HMaster进行管理类操作的通信；在获取RegionServer的信息后，直接与RegionServer进行数据读写类操作。")])])]),e._v(" "),r("li",[e._v("客户端的多种形式\n"),r("ul",[r("li",[e._v("HBase 自带的HBase shell使用Java语言来实现的客户端")])])])]),e._v(" "),r("h2",{attrs:{id:"zookeeper"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper"}},[e._v("#")]),e._v(" ZooKeeper")]),e._v(" "),r("p",[r("strong",[e._v("协调的任务")]),e._v("：")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("Master选举")]),e._v("：通过选举机制保证同一个时刻只有一个HMaster处于活跃状态。")]),e._v(" "),r("li",[r("strong",[e._v("系统容错")]),e._v("：每个RegionServer在加入集群时都需要到Zookeeper中进行注册，创\n建一个状态节点，Zookeeper会实时监控每个RegionServer的状态。")]),e._v(" "),r("li",[r("strong",[e._v("Region元数据管理")]),e._v("：Region元数据被存储在Meta表中。Meta表是存在Zookeeper中。每次客户端发起新的请求时，需要查下Meta表来获取Region的位置。另外HMaster的地址也由zookeeper告知客户端。")]),e._v(" "),r("li",[r("strong",[e._v("Region状态管理")]),e._v("：HBase 集群中region 会经常发生变更，变更的原因可能是系\n统故障，或者是配置修改，还有region 的分裂和合并。只要region 发生变化，就\n需要集群的所有节点知晓，否则就会出现异常。")])]),e._v(" "),r("h2",{attrs:{id:"hmaster"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hmaster"}},[e._v("#")]),e._v(" HMaster")]),e._v(" "),r("p",[e._v("HMaster是HBase集群中的主服务器，负责监控集群中的所有大数据存RegionServer，并且是所有元数据更改的接口储与管理. HMaster主要负责表和region的管理工作")]),e._v(" "),r("ol",[r("li",[e._v("管理用户对表的增、删、改、查操作")]),e._v(" "),r("li",[e._v("管理RegionServer的负载均衡，调整region的分布")]),e._v(" "),r("li",[e._v("Region的分配和移除")]),e._v(" "),r("li",[e._v("在RegionServer宕机或下线后，负责迁移RegionServer上的Region到其他的RegionServer上")])]),e._v(" "),r("p",[r("strong",[e._v("HMaster故障不影响当前客户端对数据的访问。但需尽快恢复，避免后续操作的正确性")]),e._v("。")]),e._v(" "),r("h2",{attrs:{id:"regionserver"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#regionserver"}},[e._v("#")]),e._v(" RegionServer")]),e._v(" "),r("p",[e._v("RegionServer主要负责响应用户的请求，向HDFS中读写数据。一般在分布式集群当中，RegionServer大数据存储与管理运行在DataNode服务器上，实现数据的本地性。每个RegionServer包含多个region，它负责的功能有：")]),e._v(" "),r("ol",[r("li",[e._v("处理客户端读写请求。")]),e._v(" "),r("li",[e._v("处理分配给它的region。")]),e._v(" "),r("li",[e._v("regionserver接收到客户端的写数据操作后，将数据缓存至\nHDFS中。")]),e._v(" "),r("li",[e._v("处理Region分片：切片在运行过程中变得过大的Region。")]),e._v(" "),r("li",[e._v("执行压缩。")])]),e._v(" "),r("h2",{attrs:{id:"hbase相关概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hbase相关概念"}},[e._v("#")]),e._v(" Hbase相关概念")]),e._v(" "),r("ol",[r("li",[r("strong",[e._v("表（ table ）")]),e._v("：HBase采用表来组织数据；同一个表的数据通常是相关的。")]),e._v(" "),r("li",[r("strong",[e._v("行（ row ）")]),e._v("：每个表都由行组成，每个行由行键（ row key ）来标识，行键可以是任意字符串；数据存储时，按照行键的字典顺序排序。在检索时，可以通过单个row key来访问数据。")]),e._v(" "),r("li",[r("strong",[e._v("列族（ column family ）")]),e._v("：一个table有许多个列族，列族是列的集合，属于表结构，也是表的基本访问控制单元；列族支持动态扩展，用户可以很轻松的添加一个列族或列，无须预定义列的数量以及类型。")]),e._v(" "),r("li",[r("strong",[e._v("列标识（column qualifier）")]),e._v("：列族中的数据通过列标识column qualifier来进行定位，通常以Column Family：Column Qualifier来确定列族中的某列，注意列族与列表之间用冒号来隔开。另外列标识是可以根据需要动态添加的。")]),e._v(" "),r("li",[r("strong",[e._v("时间戳（ timestamp ）")]),e._v("：时间戳用来区分数据的不同版本；即每个单元格保存着同一份数据的多个版本，默认情况下，每一个单元格中的数据插入时都会用时间戳来进行版本标识。读取单元格数据时，如果时间戳没有被指定，则默认返回最新的数据，写入新的单元格数据时，如果没有设置时间戳，默认使用当前时间。")]),e._v(" "),r("li",[r("strong",[e._v("单元格（ cell ）")]),e._v("：在table中，通过行、列族、列、时间戳来确定一个单元格，单元格中存储的数据没有数据类型，以二进制字节来存储，每个单元格保存着同一份数据的多个版本，不同时间版本的数据按照时间的顺序排序，最新时间的数据排在最前面。通过<RowKey，Column Family: Column Qualifier，Timestamp>元组来访问单元格。")])]),e._v(" "),r("h2",{attrs:{id:"逻辑模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#逻辑模型"}},[e._v("#")]),e._v(" 逻辑模型")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://jsdelivr.codeqihan.com//gh/xustudyxu/image-hosting@master/studynotes/HBase/images/04/01.png",alt:"01"}})]),e._v(" "),r("p",[r("strong",[e._v("关系型数据库特点：")])]),e._v(" "),r("ul",[r("li",[e._v("表结构预先定义；")]),e._v(" "),r("li",[e._v("同一列的数据类型相同;")]),e._v(" "),r("li",[e._v("空值占用存储空间")])]),e._v(" "),r("p",[r("strong",[e._v("HBase特点:")])]),e._v(" "),r("ul",[r("li",[e._v("只需要定义表名和列族可以动态添加列族和列")]),e._v(" "),r("li",[e._v("数据都是字符串类型")]),e._v(" "),r("li",[e._v("空值不占用存储空间")])]),e._v(" "),r("h2",{attrs:{id:"物理模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#物理模型"}},[e._v("#")]),e._v(" 物理模型")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://jsdelivr.codeqihan.com//gh/xustudyxu/image-hosting@master/studynotes/HBase/images/04/02.png",alt:"02"}})]),e._v(" "),r("h2",{attrs:{id:"实际存储方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实际存储方式"}},[e._v("#")]),e._v(" 实际存储方式")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://jsdelivr.codeqihan.com//gh/xustudyxu/image-hosting@master/studynotes/HBase/images/04/03.png",alt:"03"}})]),e._v(" "),r("p",[r("img",{attrs:{src:"https://jsdelivr.codeqihan.com//gh/xustudyxu/image-hosting@master/studynotes/HBase/images/04/04.png",alt:"04"}})]),e._v(" "),r("p",[e._v("表中的数据按照行键的字典序分成多个"),r("strong",[e._v("region")]),e._v("存在不同的"),r("strong",[e._v("regionserver")]),e._v("上")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://jsdelivr.codeqihan.com//gh/xustudyxu/image-hosting@master/studynotes/HBase/images/04/05.png",alt:"05"}})])])}),[],!1,null,null,null);r.default=a.exports}}]);